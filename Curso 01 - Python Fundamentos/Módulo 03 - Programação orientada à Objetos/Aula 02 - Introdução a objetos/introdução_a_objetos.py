# -*- coding: utf-8 -*-
"""Introdu√ß√£o a objetos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oyasE56n57Y65NYzwTr3HKMhlpDR4cta

#üî® Introdu√ß√£o aos objetos

Como assim *introdu√ß√£o* se falamos de objetos at√© agora? √â bem isso. O conceito de objetos √© um tanto complexo, por isso demanda um cap√≠tulo s√≥ sobre isso. Mas relaxa, voc√™ vai acabar esse notebook entendendo tudo!

# üìñ Explorando valores e refer√™ncias

At√© agora, n√≥s usamos vari√°veis dos tipos <font color = "orange"><b>`int`</font></b>, <font color = "orange"><b>`float`</font></b>, <font color = "orange"><b>`bool`</font></b>, <font color = "orange"><b>`string`</font></b>, <font color = "orange"><b>`list`</font></b> and <font color = "orange"><b>`tuple`</font></b>. Acontece que alguns desses s√£o tratados como **valores**, enquanto outros s√£o tratados como **refer√™ncias**.

Para entender o que isso significa e como implica na maneira de programarmos, esse problema vai ajud√°-lo a explorar os <font color = "orange"><b>`types`</font></b>.
"""

a = 'python'
b = 'python'

"""Nesse caso, **`a`** e **`b`** referem-se ao mesmo objeto na mem√≥ria, mais que iguais, **eles s√£o o mesmo objeto**.

Mas como podemos ter certeza disso? Como j√° fizemos antes, podemos buscar o id de uma vari√°vel com a fun√ß√£o <font color = "orange"><b>`id()`</b></font>. O Python recebe a vari√°vel e retorna o id - seu endere√ßo na mem√≥ria - do objeto que est√° atribu√≠do a ela.
"""

print(id(a))
print(id(b))
print(id(a) == id(b))
print(a is b)

"""Ent√£o os dois s√£o, de fato, o mesmo. Podemos comparar de uma maneira mais concisa: em Python, temos a palavrinha m√°gica <font color = "orange"><b>`is`</font></b> que nos diz se duas vari√°veis s√£o o mesmo objeto ou n√£o."""

a is b

"""Agora, vamos testar o mesmo c√≥digo acima com algo diferente. Em vez de "python", vamos tentar o n√∫mero 5, o n√∫mero 5.0 e o booleano True."""

a = 5
b = 5.0

id(a), id(b)

"""Perceba que o id de **`a`** √© diferente do id de **`b`**. Ent√£o..."""

a is b

"""...mas"""

a == b

"""Interessante! Ent√£o, como regra geral, temos que **objetos de diferentes tipos sempre residem em diferentes endere√ßos na mem√≥ria**.

Al√©m disso, vimos que <b>`a == b`</b> √© <b>`True`</b>, o que faz sentido, j√° que 5 e 5.0 realmente s√£o equivalentes.

Agora, vamos tentar com <font color = "orange"><b>`listas`</font></b>:
"""

a = [1, 2, 3]
b = [1, 2, 3]

a is b

a == b

"""Perceba que as <font color = "orange"><b>`listas`</b></font> s√£o tratadas diferentemente das outras classes que vimos at√© agora. Elas s√£o objetos diferentes (por terem ids diferentes), mas, como na matem√°tica, elas s√£o iguais por terem os mesmos elementos. T√° confuso, eu sei! Mas na verdade √© bem simples!! As duas <font color = "orange"><b>`listas`</b></font> s√£o iguais, porem n√£o s√£o a mesma coisa. √â quase como se elas fossem g√™meas: iguais, mas pessoas diferentes (no nosso caso, em vez de pessoas, objetos!).

Outra maneira de ver isso √© a seguinte:
"""

a[1] = 70
print(a) # Mudamos a...

print(b) # ...mas b continuou igual!

# Ent√£o temos que:
a == b

"""Mudan√ßas em uma lista n√£o afetam a outra! O que significa realmente que elas n√£o eram a mesma coisa.

Mas e se fizemos diferente:
"""

a = [1, 2, 3]
b = a

"""E mudarmos o primeiro item de b..."""

b[1] = 70

"""...o que ser√° que acontece com a?"""

a

"""Ent√£o, se ao mudarmos **`b`**, tivemos **`a`** alterado, temos que:"""

a is b

id(a), id(b)

"""E se mudarmos algo em **`a`**, ser√° que **`b`** muda tamb√©m?"""

a[1] = 70

print(a)
print(b)
print(a == b)

"""Sim!

Esse conceito √© chamado de **aliasing** (vem de *alias* - apelido), onde duas vari√°veis se referem ao mesmo objeto. Com os <font color = "orange"><b>`types`</b></font> primitivos que vimos acima, Python faz automaticamente a correspond√™ncia entre as vari√°veis se elas tem o mesmo** valor** e **tipo**. Com listas, precisamos explicitar se queremos fazer essa correspond√™ncia, igualando as vari√°veis, em vez de apenas atribu√≠-las aos mesmos valor e tipo.
"""

a = 1
b = 1
a is b

a = 1
b = a
a is b

id(a), id(b)

a += 1

"""Pode parecer confuso **`b`** n√£o ter devolvido **`2`**, mas faz sentido! **`a`** e **`b`** eram a mesma coisa, mas reatribu√≠mos um valor a **`a`**, o que significa que agora ele √© **outro objeto** e tem** outro lugar na mem√≥ria**."""

id(a), id(b) # Perceba que o id de a mudou, mas o de b continua o mesmo que o anterior.

"""Assim, para que continuemos tendo **`a`==`b`**, precisamos definir de novo isso! Isso porque para **`b`** agora ele √© o antigo **`a`**: ele foi associado ao valor de **`a`** quando **`a`** era 1. Depois que **`a`** virou outro objeto, ningu√©m disse isso pro **`b`**. Mas podemos dizer:"""

b = a
b

a is b

"""# üîÅ Explorando a mutabilidade

Agora √© a hora de realmente entender como o computador pensa e trabalha.

**Atribuir** um valor a uma vari√°vel significa algo do tipo:
"""

x = 5
y = 'Ola'
z = [1, 2, 3]

"""Modificar uma vari√°vel √© algo do tipo:"""

z.append('oi')

z

"""Sobrescrever uma vari√°vel imutavel √© diferente de mudar a variavel:"""

y = y + ' mundo'

y

"""Partindo dessas defini√ß√µes, dizemos que um objeto √© mut√°vel se ele (o objeto) puder ser mudado de qualquer maneira. Da mesma forma, dizemos que o objeto √© imut√°vel se ele n√£o suporta nenhum tipo de opera√ß√£o ou fun√ß√£o que o mude.



> **Por exemplo:**
Tanto strings quanto <font color = "orange"><b>`tuplas`</font></b> s√£o <font color = "orange"><b>`types`</b></font> imut√°veis (e, assim, n√£o podemos modificar nem <font color = "orange"><b>`strings`</font></b>, nem <font color = "orange"><b>`tuplas`</font></b>), e por serem ambas comumente usadas repetidamente, Python salva na mem√≥ria automaticamente como **aliases** (ou seja, se existe uma mesma <font color = "orange"><b>`string`</font></b>/<font color = "orange"><b>`tupla`</font></b> atribu√≠da a diferentes vari√°veis, Python entende que essas vari√°veis s√£o a mesma coisa). J√° listas, por serem mut√°veis, n√£o suportam esse tipo de **aliasing**.

Sabemos que <font color = "orange"><b>`strings`</font></b> e <font color = "orange"><b>`tuplas`</font></b> s√£o imut√°veis, ent√£o nenhuma dos operadores ou fun√ß√µes que eleas suportam teriam algum efeito colateral no objeto em si (a fun√ß√£o pode at√© imprimir algo diferente, mas o objeto n√£o √© alterado por isso).

Vamos ver:
"""

a = 'hello'

print(a.index('e'))
print(a)

print(a.upper())
print(a)

a = a.upper()  # Perceba que a string 'hello' n√£o foi alterada.
a              #O que aconteceu √© que uma nova string (a.upper()) foi atribu√≠da √† vari√°vel a

"""A primeira fun√ß√£o, <font color = "orange"><b>`index()`</font></b>, faz sentido - n√≥s n√£o esper√°vamos que mudasse a string j√° que estamos s√≥ encontrando um de seus elementos, e n√£o mudando ele. Mas e a <font color = "orange"><b>`upper()`</font></b>?

Na verdade, <font color = "orange"><b>`upper()`</font></b> n√£o mudou a string. A <font color = "orange"><b>`upper()`</font></b> `hello` ainda existe e se mant√©m inalterada. O que mudou √© o valor atribu√≠do a vari√°vel `a`, que agora √© <font color = "orange"><b>`a.upper()`</font></b>, ou seja, <font color = "orange"><b>`'hello'.upper()`</font></b>. Dizemos que **`a`** foi sobrescrito.

Esse √© um padr√£o que vai aparecer com frequ√™ncia - quando os objetos s√£o imut√°veis, eles t√™m esse tipo de  ***factory functions*** (ou ***creators***), que retornam novos objetos em vez de modificar o original.

Agora, vamos entender melhor sobre as listas. Como sabemos que elas s√£o mut√°veis, podemos esperar que algumas fun√ß√µes tenham "efeitos colaterais".
"""

b = ['x', 'y', 'z']
print(b.count('y'))
print(b)
print(b.reverse())
print(b)

"""Novamente, como o esperado, a fun√ß√£o <font color = "orange"><b>`count()`</font></b> n√£o mudou a lista, mas a fun√ß√£o <font color = "orange"><b>`reverse()`</font></b> sim, ent√£o podemos dizer que um "efeito colateral" desta fun√ß√£o √© modificar a lista `b`. √â a mesma coisa que vimos com o comando <font color = "orange"><b>`append()`</font></b>: o comando √© do tipo **`None`**, ent√£o ele n√£o tem nenhuma sa√≠da direta, apenas altera uma lista."""

x = [1, 2, 3]
x = x.append(4)
print(x)

x = [1, 2, 3]
x.append(4)
print(x)

"""Perceba nos pr√≥ximos exemplos uma grande diferen√ßa entre** modificar uma vari√°vel** e** atualizar uma vari√°vel**:** Quando modificamos uma vari√°vel ela continua ocupando o mesmo local na mem√≥ria** (tem o mesmo **`id`**), mas** quando sobrescrevemos a vari√°vel ela passa a ocupar um novo local na mem√≥ria** (recebe um novo **`id`**)

Esse conceito vai ser √∫til um pouco √† frente quando estivermos tratando sobre escopo.
"""

a = [1, 2, 3]
print(id(a), a)
a.append(4)
print(id(a), a)

b = [1, 2, 3]
print(id(b), b)
b = [1, 2, 3, 4]
print(id(b), b)

"""# üî° Vari√°veis Locais

Vamos ver agora um conceito ao qual chamamos de var√≠aveis locais, que est√° ligando principalmente √† cria√ß√£o de fun√ß√µes.

Quando criamos uma fun√ß√£o, podemos utilizar valores de vari√°veis que j√° foram definidas anteriormente, fora da fun√ß√£o, ou podemos definir novas vari√°veis dentro da nossa fun√ß√£o.

O que n√£o √© intuitivo √© que **quando criamos variaves dentro de fun√ß√µes, estas vari√°veis existem somente dentro da fun√ß√£o.** Isto √© o que chamamos de **vari√°veis locais**. Se tentarmos usar v√°riaveis locais fora da fun√ß√£o em que foram criadas nosso c√≥digo n√£o vai funcionar.
"""

def funcao(x):
    squared = x**2  #Aqui estamos criando uma vari√°vel local squared
    print(squared) #O comando print faz parte da fun√ß√£o ent√£o a vari√°vel ser√° mostrada sem problemas

x = 2
funcao(x)

print(squared) #A variav√©l squared n√£o existe fora da fun√ß√£o, pois √© uma vari√°vel local;
         #Quando tentamos chamar ela fora da fun√ßao que foi criada encontramos um erro.

"""Outra caracteristica das v√°riaveis locais, que inclusive pode ser mais "perigosa" √© a de **atualiza√ß√£o de valores por meio das vari√°veis locais**. Este erro pode acontecer quando, dentro de uma fun√ß√£o, atribu√≠mos um novo valor √† uma vari√°vel j√° existente.

Vari√°veis criadas dentro de fun√ß√µes n√£o podem ser utilizadas fora delas (logo vamos ver um comando que nos deixa fazer isso, mas esquece isso por enquanto...) mas o contr√°rio n√£o √© verdade.

Podemos utilizar v√°riaveis ja definida anteriormente dentro de fun√ß√µes, e inclusive alterar seus valores, mas **ap√≥s "sairmos" da fun√ß√£o estas vari√°veis voltam a ter seus valores anteriores**, n√£o sendo atualizados.

"""

squared = 2    #Inicialmente atribu√≠mos o valor 2 √† vari√°vel y
print(squared) #Aqui estamos printando o valor inicial de y, que √© 2
funcao(squared)#Utilizamos o valor que j√° temos de y para chamar a fun√ß√£o. Dentro dela, a variavel y recebe um novo valor igual a 4
print(squared) #Printamos novamente y, que deveria ter sido atualizada para 4, mas perceba que a vari√°vel contnua com seu valor inicial
         #Isto ocorre pois a vari√°vel y foi "atualizada localmente" dentro da fun√ß√£o apenas; fora dela seu valor cont√≠nua sendo o inicial

"""A√≠ que est√° o grande perigo de erros como este: nossa vari√°vel n√£o vai ser atualizada, mas o c√≥digo continuar√° sendo executado. Ou seja,** o c√≥digo vai ser executado com um valor errado sem nenhum tipo de aviso sobre isso**, e, se n√£o percebermos isto, teremos uma resposta mesmo assim. Resumindo: **O c√≥digo n√£o apresentar√° nenhum tipo de erro, mas nossa resposta estar√° errada!**

***
 <font color = "grey">   **Erro Sem√¢ntico X Erro Sint√°tico**

  Vamos aproveitar o momento para discutir um pouco sobre a diferen√ßa entre erros semanticos e sint√°ticos.
  
  Este erro que acabamos de descrever √© o **Erro Sem√¢ntico**. Dizemos que um erro √© do tipo sem√¢ntico quando o c√≥digo que escrevemos **pode ser executado**, mas por alguma raz√£o ele **retorna um resultado diferente do experado** (como no exemplo anterior).

**Erros Sint√°ticos** s√£o aqueles erros mais cl√°ssicos e em geral mais comuns, quando o c√≥digo que escrevemos realmente** n√£o roda** e aquela **mensagem de erro** gigante aparece no lugar da resposta. Isto acontece porque esse tipo de erro acontece justamente quando escrevemos alguma coisa que a linguagem n√£o entende (por exemplo quando utilizamos uma vari√°vel que n√£o foi definida anteriormente, utilizamos comandos ou fun√ß√µes que n√£o exitem em python, ou ainda quando esquecemos do colocar os dois pontos no final do `if`)
  
 ***

Para evitar estes erros sem√¢nticos, para que uma vari√°vel criada ou atualizada localmente tenha seu valor atualizado tambem fora de sua fun√ß√£o podemos utilizar o comando <font color = "orange"><b>`global y`</font></b>. Se ecrevermos isto dentro da fun√ß√£o, antes de criar ou atualizar nossa vari√°vel, no caso chamamos ela de y, seu valor ser√° utilizado tambem fora da fun√ß√£o.
"""

def funcao2(x):
    global y
    y = x**2
    print(y)

y = 2
print(y)
funcao2(y)
print(y)

"""# üìå Explorando o escopo

Agora que n√≥s entendemos refer√™ncias e os conceitos de **aliasing** e **mutabilidade**, vamos adicionar mais um elemento para, ent√£o, podemos juntar tudo.

Tenha certeza de que voc√™ est√° confort√°vel com o conceito de vari√°veis locais, pois vamos utilizar o mesmo conceito de vari√°veis locais dentro de fun√ß√µes. A ideia √© percebermos se essas vari√°veis s√£o refer√™ncias ou valores.

Vamos l√°:
"""

def foo(x):
    print('point 2:', id(x))
    x = [1, 2, 3]
    print('point 3:', id(x))

L = [1, 2, 3]
print('point 1:', id(L))
foo(L)
print('point 4:', id(L))

"""---
####Explicando o exemplo acima:
Criamos uma lista L e pedimos que o c√≥digo nos retorne seu **id**. Ap√≥s isto, usamos esta lista que acabamos de criar como input para nossa fun√ß√£o <font color = "orange"><b>`foo(x)`</font></b>.

Dentro do escopo da fun√ß√£o, pedimos agora o **id** da vari√°vel X (que no caso √© a lista L). Ap√≥s isto, atribuimos √† ela um novo valor, uma lista com elementos identicos √† lista L inicial, e mostramos seu novo **id**

Por fim, sa√≠mos do escopo da fun√ß√£o e mostamos novamente a o **id** da lista L.

---


Como podemos perceber, quando a lista L √© passada para dentro da fun√ß√£o <font color = "orange"><b>`foo(x)`</font></b> a vari√°vel local X √© a mesma lista que a lista L, e refere-se ao mesmo objeto (como vimos quando estavamos comentando sobre *alias*)


Ent√£o, de in√≠cio, a lista dentro da fun√ß√£o ocupa o mesmo lugar na mem√≥ria que a lista L inicial, pois s√£o o mesmo objeto. Quando atualizamos a lista dentro da fun√ß√£o, estamos criando um outro local em mem√≥ria para armazen√°-la.

Mas se voc√™ entendeu o conceito de vari√°veis locais, deve ter percebido que atualizamos a lista L dentro de uma fun√ß√£o, ent√£o apenas atualizamos uma vari√°vel local. Depois de sairmos do escopo da fun√ß√£o, a lista L "volta a ser" a mesma lista que no in√≠cio, inclusive referenciando o mesmo **id**.

---

Temos ainda uma peculiaridade dentro deste conceito de escopo quando utilizamos de fun√ß√µes que alteram objetos. Para entender essa peculiaridade precisamos lembrar do conceito de mutabilidade.

Como vimos l√° atr√°s, na parte que trata de mutabilidade, quando utlizamos **fun√ß√µes que alteram um objeto** (como o comando <font color = "orange"><b>`append()`</font></b>), ele continua ocupando o mesmo local na mem√≥ria. Apenas o valor do objeto que √© atualizado, como podemos ver no exemplo a seguir:
"""

L=[1,2,3]
print(id(L), L)
L.append(4)
print(id(L), L)

"""O que acontece quando utilizamos v√°riaveis deste tipo dentro do escopo de uma fun√ß√£o √© que nossa vari√°vel, mesmo sendo atualizada localmente, continua com o valor atualizado fora do escopo da fun√ß√£o. Isto porque o comando <font color = "orange"><b>`append()`</font></b> atualiza a vari√°vel mantendo seu **id**, ou seja, atualiza o mesmo local na mem√≥ria.


Note que no pr√≥ximo exemplo, diferente do exemplo anterior, o **id** da lista L fora e dentro da fun√ß√£o √© o mesmo nas 4 vezes, mas seu valor muda nas duas √∫ltimas.
"""

def foo(x):
    print('point 2:',id(x), x)
    x.append(4)
    print('point 3:', id(x), x)

L = [1, 2, 3]
print('point 1:', id(L), L)
foo(L)
print('point 4:', id(L), L)
